{% extends "base.html" %}

{% block content %}
<div class="uuid-container">
    <div class="uuid-sidebar">
        <div class="sidebar-header">
            <h3>UUID Guide</h3>
        </div>
        <nav class="uuid-nav">
            <ul>
                <!-- <li><a href="#introduction">Introduction to UUID</a></li> -->
                <li><a href="#what-is-uuid">What is a UUID?</a></li>
                <li class="has-submenu">
                    <a href="#types" class="submenu-toggle">UUID Types & Versions <span class="dropdown-arrow">▼</span></a>
                    <ul class="submenu">
                        <li><a href="#version1">Version 1 (Time-based)</a></li>
                        <li><a href="#version2">Version 2 (DCE Security)</a></li>
                        <li><a href="#version3">Version 3 (Name-based, MD5)</a></li>
                        <li><a href="#version4">Version 4 (Random)</a></li>
                        <li><a href="#version5">Version 5 (Name-based, SHA-1)</a></li>
                        <li><a href="#version678">Version 6, 7, 8 (Proposed)</a></li>
                    </ul>
                </li>
                <li><a href="#generation">UUID Generation</a></li>
                <li><a href="#security">Security Considerations</a></li>
                <li><a href="#use-cases">Common Use Cases</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
                <li><a href="#uuid-vs-guid">UUID vs GUID</a></li>
                <li><a href="#advantages">Advantages of UUID</a></li>
                <li><a href="#disadvantages">Limitations</a></li>
                <li class="has-submenu">
                    <a href="#implementation" class="submenu-toggle">Implementation Examples <span class="dropdown-arrow">▼</span></a>
                    <ul class="submenu">
                        <li><a href="#python">Python</a></li>
                        <li><a href="#javascript">JavaScript</a></li>
                        <li><a href="#sql">SQL</a></li>
                    </ul>
                </li>
                <li><a href="#future">Future of UUID</a></li>
            </ul>
        </nav>
    </div>
    <div class="uuid-content">
        <h1 id="introduction">Understanding UUID: The Complete Guide</h1>
        
        <section id="what-is-uuid">
            <h2>What is a UUID?</h2>
            <p>A Universally Unique Identifier (UUID) is a 128-bit identifier that is generated according to standardized methods to ensure uniqueness across space and time. UUIDs are designed to be globally unique without requiring a central registration authority or coordination between parties generating them.</p>
            <p>The standard representation of a UUID is a 32-character hexadecimal string, divided into five groups separated by hyphens, in the format 8-4-4-4-12, for example: <code>550e8400-e29b-41d4-a716-446655440000</code>.</p>
        </section>
        
        <section id="types">
            <h2>UUID Types & Versions</h2>
            <p>The UUID specification defines several versions, each with different generation mechanisms:</p>
            <h3>Version 1 (Time-based)</h3>
            <p>Generated using the current timestamp and MAC address of the computer. Provides uniqueness through spatial-temporal coordinates.</p>
            
            <h3>Version 2 (DCE Security)</h3>
            <p>Similar to Version 1, but includes domain components for security purposes. Less commonly implemented.</p>
            
            <h3>Version 3 (Name-based, MD5)</h3>
            <p>Generated by hashing a namespace identifier and name using MD5. Produces consistent results for the same inputs.</p>
            
            <h3>Version 4 (Random)</h3>
            <p>Generated using random or pseudo-random numbers. The most widely used version due to its simplicity and privacy advantages.</p>
            
            <h3>Version 5 (Name-based, SHA-1)</h3>
            <p>Similar to Version 3, but uses SHA-1 instead of MD5, providing better cryptographic properties.</p>
            
            <h3>Version 6, 7, 8 (Proposed)</h3>
            <p>Newer versions addressing specific use cases including sortability, improved time-based generation, and custom generation methods.</p>
        </section>
        
        <section id="generation">
            <h2>UUID Generation</h2>
            <p>UUID generation varies by version, but follows specific algorithms to ensure uniqueness:</p>
            <ul>
                <li><strong>Hardware-based generation:</strong> Using MAC addresses and timestamps (v1)</li>
                <li><strong>Cryptographic hash functions:</strong> Creating deterministic values from namespaces and names (v3, v5)</li>
                <li><strong>Random number generators:</strong> Using cryptographically secure PRNGs for unpredictable values (v4)</li>
            </ul>
            <p>Most programming languages and databases provide built-in functions for UUID generation, making implementation straightforward.</p>
        </section>
        
        <section id="security">
            <h2>Security Considerations</h2>
            <p>UUIDs have various security implications depending on the version used:</p>
            <ul>
                <li>Version 1 UUIDs can potentially leak MAC addresses and timing information.</li>
                <li>Version 4 UUIDs provide better privacy but rely on the quality of the random number generator.</li>
                <li>UUIDs should not be used as security tokens without additional measures.</li>
                <li>The predictability of version 3 and 5 UUIDs makes them unsuitable for security-sensitive scenarios.</li>
            </ul>
            <p>For applications where security is critical, consider using dedicated cryptographic techniques alongside or instead of UUIDs.</p>
        </section>
        
        <section id="use-cases">
            <h2>Common Use Cases</h2>
            <p>UUIDs are versatile identifiers used in numerous contexts:</p>
            <ul>
                <li><strong>Database primary keys:</strong> Especially in distributed systems where coordinated ID generation is impractical</li>
                <li><strong>Distributed systems:</strong> For generating identifiers across multiple nodes without coordination</li>
                <li><strong>Content addressing:</strong> For uniquely identifying content or resources</li>
                <li><strong>Session identifiers:</strong> For tracking user sessions in web applications</li>
                <li><strong>Transaction IDs:</strong> For uniquely identifying transactions across systems</li>
                <li><strong>API request identifiers:</strong> For tracking and correlating API requests</li>
            </ul>
        </section>
        
        <section id="best-practices">
            <h2>Best Practices</h2>
            <p>When working with UUIDs, consider these best practices:</p>
            <ul>
                <li>Choose the appropriate UUID version for your use case (v4 for most general purposes)</li>
                <li>Consider storage implications (128 bits is larger than sequential integers)</li>
                <li>Be aware of index performance in databases (UUIDs don't cluster naturally)</li>
                <li>Use appropriate data types in databases (use UUID/GUID types rather than strings when available)</li>
                <li>For high-performance systems, consider alternatives like ULID or KSUID that offer better sortability</li>
            </ul>
        </section>
        
        <section id="uuid-vs-guid">
            <h2>UUID vs GUID</h2>
            <p>While the terms are often used interchangeably, there are subtle differences:</p>
            <ul>
                <li>UUID is the standard defined by RFC 4122</li>
                <li>GUID (Globally Unique Identifier) is Microsoft's implementation of the UUID standard</li>
                <li>GUIDs typically follow the same format and generation methods as UUIDs</li>
                <li>Some Microsoft systems store GUIDs in a different byte order than canonical UUIDs</li>
            </ul>
            <p>For most practical purposes, UUIDs and GUIDs can be considered equivalent.</p>
        </section>
        
        <section id="advantages">
            <h2>Advantages of UUID</h2>
            <p>UUIDs offer several benefits over other identifier schemes:</p>
            <ul>
                <li><strong>Decentralized generation:</strong> No coordination needed between systems</li>
                <li><strong>Global uniqueness:</strong> Practically eliminates the risk of collisions</li>
                <li><strong>No sequential patterns:</strong> Improved security by avoiding predictable IDs</li>
                <li><strong>Cross-system compatibility:</strong> Widely supported across languages and platforms</li>
                <li><strong>URL-safe:</strong> Can be safely used in URLs without encoding</li>
            </ul>
        </section>
        
        <section id="disadvantages">
            <h2>Limitations</h2>
            <p>UUIDs are not ideal for every scenario:</p>
            <ul>
                <li><strong>Size:</strong> 128 bits (16 bytes) is larger than sequential integers</li>
                <li><strong>Readability:</strong> Not human-friendly or memorable</li>
                <li><strong>Database performance:</strong> Can impact indexing and storage efficiency</li>
                <li><strong>Not sortable:</strong> Standard UUIDs don't preserve creation order (except specialized versions)</li>
                <li><strong>Overhead:</strong> Generation may be more computationally expensive than simpler ID schemes</li>
            </ul>
        </section>
        
        <section id="implementation">
            <h2>Implementation Examples</h2>
            <h3>Python</h3>
            <pre><code>import uuid

# Generate a random UUID (v4)
random_uuid = uuid.uuid4()
print(random_uuid)

# Generate a UUID based on a namespace and name (v5)
namespace_uuid = uuid.uuid5(uuid.NAMESPACE_DNS, 'example.com')
print(namespace_uuid)
</code></pre>

            <h3>JavaScript</h3>
            <pre><code>// Using the crypto API
function uuidv4() {
  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
}

console.log(uuidv4());

// Using a library like uuid
// npm install uuid
const { v4: uuidv4 } = require('uuid');
console.log(uuidv4());
</code></pre>

            <h3>SQL</h3>
            <pre><code>-- PostgreSQL
SELECT gen_random_uuid();

-- MySQL 8.0+
SELECT UUID();

-- SQL Server
SELECT NEWID();
</code></pre>
        </section>
        
        <section id="future">
            <h2>Future of UUID</h2>
            <p>The UUID standard continues to evolve with new versions addressing specific needs:</p>
            <ul>
                <li>UUIDv6: Sortable, time-ordered UUIDs for better database performance</li>
                <li>UUIDv7: Time-ordered with Unix timestamp for better sortability</li>
                <li>UUIDv8: Reserved for future formats and custom use cases</li>
            </ul>
            <p>Alternative identifier schemes like ULID, KSUID, and xid are also gaining popularity for specific use cases where UUID limitations are problematic.</p>
        </section>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const submenuToggles = document.querySelectorAll('.submenu-toggle');
        
        submenuToggles.forEach(toggle => {
            toggle.addEventListener('click', function(e) {
                e.preventDefault();
                const parentLi = this.parentElement;
                parentLi.classList.toggle('active');
            });
        });

        // Auto-expand the submenu of the active section based on URL hash
        function expandActiveSubmenu() {
            const hash = window.location.hash;
            if (hash) {
                const targetLink = document.querySelector(`.submenu a[href="${hash}"]`);
                if (targetLink) {
                    const parentLi = targetLink.closest('.has-submenu');
                    if (parentLi) {
                        parentLi.classList.add('active');
                    }
                }
            }
        }
        
        expandActiveSubmenu();
        
        // Re-check when hash changes
        window.addEventListener('hashchange', expandActiveSubmenu);
    });
</script>
{% endblock %} 